<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blue Square</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; background: #000; overflow: hidden; }
        #canvas { display: block; }
        #info {
            position: absolute; top: 20px; left: 20px; color: white;
            font-size: 14px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            user-select: none; z-index: 10; line-height: 1.6;
        }
        #controls {
            position: absolute; bottom: 20px; left: 20px; color: white;
            font-size: 12px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            user-select: none; z-index: 10; line-height: 1.8;
        }
        .key {
            display: inline-block; padding: 2px 6px;
            background: rgba(255,255,255,0.2); border-radius: 3px; margin-right: 4px;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="loading">
        <div>Loading Blue Square...</div>
        <div id="loadProgress">0%</div>
    </div>
    <div id="info" style="display: none;">
        <div><strong>BLUE SQUARE</strong></div>
        <div>Mode: <span id="mode">Uniform</span></div>
        <div>Preset: <span id="preset">-</span></div>
        <div>Grid: <span id="cells">64</span> cells</div>
        <div>Beat: <span id="beat">1/8</span></div>
    </div>
    <div id="controls" style="display: none;">
        <div><span class="key">M</span> Mode | <span class="key">P</span> Pause | <span class="key">D</span> Background</div>
        <div><span class="key">↑↓</span> Speed | <span class="key">←→</span> Add/Remove Cells | <span class="key">Wheel</span> Zoom</div>
        <div><span class="key">1-7</span> Jump Preset (Mode 2 only)</div>
    </div>

    <script>
        const TOTAL_IMAGES = 230;
        const BATCH_SIZE = 30;
        const DEFAULT_CELLS = 1;
        const FPS = 60;
        const FRAMES_PER_BEAT = 30;
        
        let mode = 1;
        let currentPreset = 0;
        let cellCount = DEFAULT_CELLS;
        let paused = false;
        let animationSpeed = 1.0;
        let scale = 1.0;
        
        let images = [];
        let loadedImages = new Set();
        let grid = [];
        let cols = 0, rows = 0, cellSize = 0;
        
        // Mode 1: All cells show same uniform image
        let uniformImage = 0;
        let nextUniformImage = 0;
        let uniformTransitioning = false;
        let uniformTransitionProgress = 0;
        
        // Mode 2: Each cell independent with background
        let backgroundImage = null;
        
        let frameCount = 0;
        let beatCount = 0;
        
        // Background color
        let backgroundColor = '#000';
        
        // Key press tracking for long press
        let leftPressed = false;
        let rightPressed = false;
        let keyPressInterval = null;
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const presets = [
            { name: 'Calm', speed: 0.3, changeRate: 0.1 },
            { name: 'Breathing', speed: 0.6, changeRate: 0.2 },
            { name: 'Waves', speed: 0.8, changeRate: 0.3 },
            { name: 'Sparse', speed: 0.5, changeRate: 0.15 },
            { name: 'Dense', speed: 1.0, changeRate: 0.4 },
            { name: 'Energetic', speed: 1.5, changeRate: 0.5 },
            { name: 'Glitch', speed: 2.0, changeRate: 0.7 }
        ];
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            calculateLayout();
        }
        
        function calculateLayout() {
            cols = Math.max(1, Math.ceil(Math.sqrt(cellCount)));
            rows = Math.ceil(cellCount / cols);
            const cellWidth = Math.floor(canvas.width / cols);
            const cellHeight = Math.floor(canvas.height / rows);
            cellSize = Math.min(cellWidth, cellHeight) * scale;
            updateInfo();
        }
        
        async function loadImages() {
            // Load first 10 images immediately to start faster
            const initialPromises = [];
            for (let i = 1; i <= 10; i++) {
                const idx = i - 1;
                initialPromises.push(new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        images[idx] = img;
                        loadedImages.add(idx);
                        document.getElementById('loadProgress').textContent = Math.floor(((i / TOTAL_IMAGES) * 100)) + '%';
                        resolve();
                    };
                    img.onerror = () => resolve();
                    img.src = `images/blue-${i}.jpg`;
                }));
            }
            
            await Promise.all(initialPromises);
            
            // Start the app immediately
            document.getElementById('loading').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            initializeGrid();
            animate();
            
            // Continue loading rest in background
            let loaded = 10;
            for (let batch = 1; batch < Math.ceil(TOTAL_IMAGES / BATCH_SIZE); batch++) {
                const start = batch * BATCH_SIZE + 1;
                const end = Math.min((batch + 1) * BATCH_SIZE, TOTAL_IMAGES);
                
                const promises = [];
                for (let i = start; i <= end; i++) {
                    const idx = i - 1;
                    promises.push(new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            images[idx] = img;
                            loadedImages.add(idx);
                            loaded++;
                            resolve();
                        };
                        img.onerror = () => { loaded++; resolve(); };
                        img.src = `images/blue-${i}.jpg`;
                    }));
                }
                
                await Promise.all(promises);
            }
        }
        
        function initializeGrid() {
            uniformImage = Math.floor(Math.random() * TOTAL_IMAGES);
            uniformTransitioning = false;
            
            backgroundImage = Math.random() < 0.4 ? null : Math.floor(Math.random() * TOTAL_IMAGES);
            
            grid = [];
            for (let i = 0; i < cellCount; i++) {
                grid.push({
                    imageIndex: Math.floor(Math.random() * TOTAL_IMAGES),
                    nextImageIndex: 0,
                    visible: Math.random() < 0.7,
                    transitioning: false,
                    transitionProgress: 0,
                    updateOffset: Math.random() * 0.3
                });
            }
        }
        
        function addCell() {
            if (cellCount < 400) {
                cellCount++;
                grid.push({
                    imageIndex: Math.floor(Math.random() * TOTAL_IMAGES),
                    nextImageIndex: 0,
                    visible: true,
                    transitioning: false,
                    transitionProgress: 0,
                    updateOffset: Math.random() * 0.3
                });
                calculateLayout();
            }
        }
        
        function removeCell() {
            if (cellCount > 1) {
                cellCount--;
                grid.pop();
                calculateLayout();
            }
        }
        
        function updateUniform() {
            frameCount++;
            if (frameCount >= FRAMES_PER_BEAT / animationSpeed) {
                frameCount = 0;
                beatCount++;
                
                if (beatCount % 8 === 0) {
                    nextUniformImage = Math.floor(Math.random() * TOTAL_IMAGES);
                    uniformTransitioning = true;
                    uniformTransitionProgress = 0;
                }
                updateInfo();
            }
            
            if (uniformTransitioning) {
                uniformTransitionProgress += 0.15;
                if (uniformTransitionProgress >= 1.0) {
                    uniformImage = nextUniformImage;
                    uniformTransitioning = false;
                    uniformTransitionProgress = 0;
                }
            }
        }
        
        function updateRandom() {
            frameCount++;
            const preset = presets[currentPreset];
            
            if (frameCount >= FRAMES_PER_BEAT / (animationSpeed * preset.speed)) {
                frameCount = 0;
                beatCount++;
                
                for (let cell of grid) {
                    if (MathbackgroundColorm() < (preset.changeRate + cell.updateOffset * 0.1)) {
                        cell.nextImageIndex = Math.floor(Math.random() * TOTAL_IMAGES);
                        cell.transitioning = true;
                        cell.transitionProgress = 0;
                        cell.visible = Math.random() > 0.1;
                    }
                }
                updateInfo();
            }
            
            for (let cell of grid) {
                if (cell.transitioning) {
                    cell.transitionProgress += 0.12;
                    if (cell.transitionProgress >= 1.0) {
                        cell.imageIndex = cell.nextImageIndex;
                        cell.transitioning = false;
                        cell.transitionProgress = 0;
                    }
                }
            }
        }
        
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const offsetX = (canvas.width - (cellSize * cols)) / 2;
            const offsetY = (canvas.height - (cellSize * rows)) / 2;
            
            if (mode === 1) {
                // MODE 1: All cells show the SAME uniform image
                const oldImg = images[uniformImage];
                const newImg = images[nextUniformImage];
                
                for (let i = 0; i < cellCount; i++) {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = offsetX + (col * cellSize);
                    const y = offsetY + (row * cellSize);
                    
                    if (uniformTransitioning && oldImg && newImg) {
                        ctx.globalAlpha = 1.0 - uniformTransitionProgress;
                        ctx.drawImage(oldImg, x, y, cellSize, cellSize);
                        ctx.globalAlpha = uniformTransitionProgress;
                        ctx.drawImage(newImg, x, y, cellSize, cellSize);
                        ctx.globalAlpha = 1.0;
                    } else if (oldImg) {
                        ctx.drawImage(oldImg, x, y, cellSize, cellSize);
                    }
                }
            } else {
                // MODE 2: Each cell independent with background
                for (let i = 0; i < grid.length && i < cellCount; i++) {
                    const cell = grid[i];
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = offsetX + (col * cellSize);
                    const y = offsetY + (row * cellSize);
                    
                    if (!cell.visible) {
                        if (backgroundImage !== null) {
                            const bgImg = images[backgroundImage];
                            if (bgImg) ctx.drawImage(bgImg, x, y, cellSize, cellSize);
                        }
                        continue;
                    }
                    
                    if (cell.transitioning) {
                        const oldImg = images[cell.imageIndex];
                        const newImg = images[cell.nextImageIndex];
                        if (oldImg) {
                            ctx.globalAlpha = 1.0 - cell.transitionProgress;
                            ctx.drawImage(oldImg, x, y, cellSize, cellSize);
                        }
                        if (newImg) {
                            ctx.globalAlpha = cell.transitionProgress;
                            ctx.drawImage(newImg, x, y, cellSize, cellSize);
                        }
                        ctx.globalAlpha = 1.0;
                    } else {
                        const img = images[cell.imageIndex];
                        if (img) ctx.drawImage(img, x, y, cellSize, cellSize);
                    }
                }
            }
        }
        
        function animate() {
            if (!paused) {
                if (mode === 1) updateUniform();
                else updateRandom();
            }
            draw();
            requestAnimationFrame(animate);
        }
        
        function updateInfo() {
            document.getElementById('mode').textContent = mode === 1 ? 'Uniform' : 'Random';
            document.getElementById('preset').textContent = mode === 2 ? presets[currentPreset].name : '-';
            document.getElementById('cells').textContent = cellCount;
            document.getElementById('beat').textContent = `${(beatCount % 8) + 1}/8`;
        }
        
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'm':
                    mode = mode === 1 ? 2 : 1;
                    frameCount = 0;
                    beatCount = 0;
                    updateInfo();
                    break;
                case 'p':
                    paused = !paused;
                    break;
                case 'd':
                    backgroundColor = backgroundColor === '#000' ? '#fff' : '#000';
                    break;
                case 'arrowleft':
                    if (!leftPressed) {
                        leftPressed = true;
                        removeCell();
                        // Start long press after 300ms
                        setTimeout(() => {
                            if (leftPressed && !keyPressInterval) {
                                keyPressInterval = setInterval(() => {
                                    if (leftPressed) removeCell();
                                }, 50);
                            }
                        }, 300);
                    }
                    break;
                case 'arrowright':
                    if (!rightPressed) {
                        rightPressed = true;
                        addCell();
                        // Start long press after 300ms
                        setTimeout(() => {
                            if (rightPressed && !keyPressInterval) {
                                keyPressInterval = setInterval(() => {
                                    if (rightPressed) addCell();
                                }, 50);
                            }
                        }, 300);
                    }
                    break;
                case 'arrowup':
                    animationSpeed = Math.min(5.0, animationSpeed + 0.2);
                    break;
                case 'arrowdown':
                    animationSpeed = Math.max(0.1, animationSpeed - 0.2);
                    break;
                case '1': case '2': case '3': case '4': case '5': case '6': case '7':
                    if (mode === 2) {
            // Zoom in/out
            if (e.deltaY < 0) {
                scale = Math.min(2.0, scale + 0.05);
            } else {
                scale = Math.max(0.3, scale - 0.05);
            }t') {
                rightPressed = false;
                if (keyPressInterval) {
                    clearInterval(keyPressInterval);
                    keyPressInterval = null;
                }
            }
        });
        
        document.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY < 0) {
                cellCount = Math.min(400, cellCount + 4);
            } else {
                cellCount = Math.max(4, cellCount - 4);
            }
            while (grid.length < cellCount) {
                grid.push({
                    imageIndex: Math.floor(Math.random() * TOTAL_IMAGES),
                    nextImageIndex: 0,
                    visible: true,
                    transitioning: false,
                    transitionProgress: 0,
                    updateOffset: Math.random() * 0.3
                });
            }
            grid.length = cellCount;
            calculateLayout();
        });
        
        window.addEventListener('resize', resizeCanvas);
        
        resizeCanvas();
        loadImages();
    </script>
</body>
</html>
        
        
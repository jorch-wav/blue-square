<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blue Square - Audio-Reactive Visual Art</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Monaco', 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
        }
        
        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.6;
            max-width: 300px;
            z-index: 100;
            transition: opacity 0.3s;
        }
        
        #controls.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
        }
        
        .key {
            display: inline-block;
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 2px;
            font-weight: bold;
            color: #0ff;
        }
        
        h3 {
            color: #0ff;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        .mode-indicator {
            color: #ff0;
            font-weight: bold;
        }
        
        #startButton {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 24px;
            background: #0ff;
            color: #000;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            z-index: 200;
            transition: all 0.3s;
        }
        
        #startButton:hover {
            background: #fff;
            transform: translate(-50%, -50%) scale(1.05);
        }
        
        #startButton.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <button id="startButton">Click to Start</button>
    
    <div id="container">
        <canvas id="canvas"></canvas>
    </div>
    
    <div id="controls">
        <h3>Controls</h3>
        <div class="control-group">
            <span class="key">M</span> Toggle Mode<br>
            <span class="key">D</span> Toggle Background<br>
            <span class="key">P</span> Pause<br>
            <span class="key">I</span> Hide Info
        </div>
        <div class="control-group">
            <span class="key">←</span><span class="key">→</span> Add/Remove Cells<br>
            <span class="key">Shift</span><span class="key">←</span><span class="key">→</span> Add/Remove 5 Cells<br>
            <span class="key">Scroll</span> Zoom In/Out
        </div>
        <div class="control-group">
            <strong>Mode 2 Presets:</strong><br>
            <span class="key">1</span> Calm
            <span class="key">2</span> Breathing<br>
            <span class="key">3</span> Waves
            <span class="key">4</span> Sparse<br>
            <span class="key">5</span> Dense
            <span class="key">6</span> Chaos<br>
            <span class="key">7</span> Flicker
        </div>
    </div>
    
    <div id="info">
        Mode: <span class="mode-indicator" id="modeText">Uniform</span> | 
        Cells: <span id="cellCount">1</span> | 
        BPM: <span id="bpmText">120</span> | 
        BG: <span id="bgText">White</span>
    </div>

    <script>
        // Configuration
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        // Set canvas to match window size with device pixel ratio for crisp rendering
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            ctx.scale(dpr, dpr);
            // Re-enable smoothing after resize (canvas resize resets context)
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // State
        let images = [];
        let totalCells = 1;
        let mode = 1; // 1 = Uniform, 2 = Random
        let bpm = 120;
        let paused = false;
        let showInfo = true;
        let canvasColor = '#FFFFFF';
        let imageGrid = [];
        let lastBeatTime = Date.now();
        let beatInterval = 60000 / bpm;
        let mode1BeatCounter = 0;
        let zoomLevel = 1.0; // Zoom state (0.1 = small grid, 1.0 = full screen height)
        const MODE1_BEAT_INTERVAL = 8;
        
        // Mode 2 state
        let currentRandomMode = 0;
        let mode2Cells = [];
        let mode2Background = null;
        let mode2BgTimer = 0;
        let mode2Waves = [];
        
        // Random mode presets
        const RANDOM_MODES = {
            0: { name: 'Calm', minChange: 2.0, maxChange: 5.0, blankChance: 0.15, imageChance: 0.85, waveChance: 0.005, waveSize: [2, 4], waveSpeed: 200, bgChangeMin: 8.0, bgChangeMax: 15.0 },
            1: { name: 'Breathing', minChange: 0.8, maxChange: 2.0, blankChance: 0.40, imageChance: 0.60, waveChance: 0.01, waveSize: [5, 15], waveSpeed: 150, bgChangeMin: 4.0, bgChangeMax: 8.0 },
            2: { name: 'Waves', minChange: 1.5, maxChange: 4.0, blankChance: 0.30, imageChance: 0.70, waveChance: 0.05, waveSize: [8, 20], waveSpeed: 80, bgChangeMin: 3.0, bgChangeMax: 6.0 },
            3: { name: 'Sparse', minChange: 1.0, maxChange: 3.0, blankChance: 0.70, imageChance: 0.30, waveChance: 0.02, waveSize: [3, 8], waveSpeed: 120, bgChangeMin: 5.0, bgChangeMax: 10.0 },
            4: { name: 'Dense', minChange: 0.5, maxChange: 2.0, blankChance: 0.10, imageChance: 0.90, waveChance: 0.01, waveSize: [2, 5], waveSpeed: 100, bgChangeMin: 6.0, bgChangeMax: 12.0 },
            5: { name: 'Chaos', minChange: 0.1, maxChange: 0.5, blankChance: 0.50, imageChance: 0.50, waveChance: 0.08, waveSize: [5, 15], waveSpeed: 40, bgChangeMin: 1.0, bgChangeMax: 3.0 },
            6: { name: 'Flicker', minChange: 0.05, maxChange: 0.3, blankChance: 0.35, imageChance: 0.65, waveChance: 0.03, waveSize: [1, 3], waveSpeed: 30, bgChangeMin: 2.0, bgChangeMax: 5.0 }
        };
        
        // Layout cache
        let cachedCellSize = 0;
        let cachedOffsetX = 0;
        let cachedOffsetY = 0;
        let rows = 1;
        let cols = 1;
        
        // Load actual blue images
        async function loadImages() {
            const imagePromises = [];
            
            // Load all 230 blue images (skipping blue-57.jpg which doesn't exist)
            for (let i = 1; i <= 231; i++) {
                if (i === 57) continue; // Skip missing image
                
                const img = new Image();
                const promise = new Promise((resolve, reject) => {
                    img.onload = () => resolve(img);
                    img.onerror = () => resolve(null); // Don't fail on missing images
                });
                img.src = `images/blue-${i}.jpg`;
                imagePromises.push(promise);
            }
            
            const loadedImgs = await Promise.all(imagePromises);
            images = loadedImgs.filter(img => img !== null);
            console.log(`Loaded ${images.length} images`);
        }
        
        // Update layout
        function updateLayout() {
            cols = Math.max(1, Math.ceil(Math.sqrt(totalCells)));
            rows = Math.ceil(totalCells / cols);
            
            // Use display size (not internal canvas resolution)
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;
            
            // Zoom determines how much of the screen height the grid takes
            const targetHeight = displayHeight * zoomLevel;
            const targetWidth = displayWidth * zoomLevel;
            
            // Calculate cell size to fit the zoom level
            const cellSizeByHeight = Math.floor(targetHeight / rows);
            const cellSizeByWidth = Math.floor(targetWidth / cols);
            cachedCellSize = Math.min(cellSizeByHeight, cellSizeByWidth);
            
            const gridWidth = cols * cachedCellSize;
            const gridHeight = rows * cachedCellSize;
            cachedOffsetX = (displayWidth - gridWidth) / 2;
            cachedOffsetY = (displayHeight - gridHeight) / 2;
        }
        
        // Initialize grid
        function initializeGrid() {
            imageGrid = [];
            const img = images[Math.floor(Math.random() * images.length)];
            for (let i = 0; i < totalCells; i++) {
                imageGrid.push(img);
            }
            updateLayout();
        }
        
        // Initialize Mode 2
        function initializeMode2() {
            const settings = RANDOM_MODES[currentRandomMode];
            mode2Cells = [];
            
            for (let i = 0; i < totalCells; i++) {
                mode2Cells.push({
                    image: images[Math.floor(Math.random() * images.length)],
                    isBlank: false,
                    timer: settings.minChange + Math.random() * (settings.maxChange - settings.minChange),
                    inWave: false
                });
            }
            
            mode2Background = images[Math.floor(Math.random() * images.length)];
            mode2BgTimer = settings.bgChangeMin + Math.random() * (settings.bgChangeMax - settings.bgChangeMin);
            mode2Waves = [];
        }
        
        // Update Mode 2
        function updateMode2(deltaSeconds) {
            const settings = RANDOM_MODES[currentRandomMode];
            
            // Update background timer
            mode2BgTimer -= deltaSeconds;
            if (mode2BgTimer <= 0) {
                mode2Background = images[Math.floor(Math.random() * images.length)];
                mode2BgTimer = settings.bgChangeMin + Math.random() * (settings.bgChangeMax - settings.bgChangeMin);
            }
            
            // Update waves
            for (let i = mode2Waves.length - 1; i >= 0; i--) {
                mode2Waves[i].position += settings.waveSpeed * deltaSeconds;
                if (mode2Waves[i].position > cols + mode2Waves[i].size) {
                    mode2Waves.splice(i, 1);
                }
            }
            
            // Maybe spawn new wave
            if (Math.random() < settings.waveChance) {
                mode2Waves.push({
                    row: Math.floor(Math.random() * rows),
                    position: 0,
                    size: settings.waveSize[0] + Math.floor(Math.random() * (settings.waveSize[1] - settings.waveSize[0]))
                });
            }
            
            // Update cells
            for (let idx = 0; idx < mode2Cells.length; idx++) {
                const cell = mode2Cells[idx];
                const row = Math.floor(idx / cols);
                const col = idx % cols;
                
                // Check if in wave
                cell.inWave = false;
                for (const wave of mode2Waves) {
                    if (wave.row === row && wave.position <= col && col < wave.position + wave.size) {
                        cell.inWave = true;
                        cell.isBlank = true;
                        break;
                    }
                }
                
                // Update timer
                if (!cell.inWave) {
                    cell.timer -= deltaSeconds;
                    if (cell.timer <= 0) {
                        const rand = Math.random();
                        if (rand < settings.blankChance) {
                            cell.isBlank = true;
                            cell.image = null;
                        } else {
                            cell.isBlank = false;
                            cell.image = images[Math.floor(Math.random() * images.length)];
                        }
                        cell.timer = settings.minChange + Math.random() * (settings.maxChange - settings.minChange);
                    }
                }
            }
        }
        
        // Draw grid
        function drawGrid() {
            // Fill background using display size
            ctx.fillStyle = canvasColor;
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
            
            for (let idx = 0; idx < totalCells; idx++) {
                const row = Math.floor(idx / cols);
                const col = idx % cols;
                const x = cachedOffsetX + col * cachedCellSize;
                const y = cachedOffsetY + row * cachedCellSize;
                
                let imgToDraw = null;
                
                if (mode === 2 && idx < mode2Cells.length) {
                    const cell = mode2Cells[idx];
                    if (cell.isBlank) {
                        imgToDraw = mode2Background;
                    } else {
                        imgToDraw = cell.image;
                    }
                } else {
                    imgToDraw = imageGrid[idx];
                }
                
                if (imgToDraw) {
                    ctx.drawImage(imgToDraw, x, y, cachedCellSize, cachedCellSize);
                } else {
                    // Empty cells match canvas background
                    ctx.fillStyle = canvasColor;
                    ctx.fillRect(x, y, cachedCellSize, cachedCellSize);
                }
            }
        }
        
        // Update UI
        function updateUI() {
            document.getElementById('modeText').textContent = mode === 1 ? 'Uniform' : `Random (${RANDOM_MODES[currentRandomMode].name})`;
            document.getElementById('cellCount').textContent = totalCells;
            document.getElementById('bpmText').textContent = bpm;
            document.getElementById('bgText').textContent = canvasColor === '#FFFFFF' ? 'White' : 'Black';
            
            if (!showInfo) {
                document.getElementById('info').style.display = 'none';
                document.getElementById('controls').classList.add('hidden');
            } else {
                document.getElementById('info').style.display = 'block';
                document.getElementById('controls').classList.remove('hidden');
            }
        }
        
        // Animation loop
        let lastFrameTime = Date.now();
        function animate() {
            const now = Date.now();
            const delta = now - lastFrameTime;
            lastFrameTime = now;
            const deltaSeconds = delta / 1000;
            
            if (!paused) {
                // Beat detection
                if (now - lastBeatTime >= beatInterval) {
                    lastBeatTime = now;
                    
                    if (mode === 1) {
                        mode1BeatCounter++;
                        if (mode1BeatCounter >= MODE1_BEAT_INTERVAL) {
                            mode1BeatCounter = 0;
                            const newImage = images[Math.floor(Math.random() * images.length)];
                            for (let i = 0; i < totalCells; i++) {
                                imageGrid[i] = newImage;
                            }
                        }
                    }
                }
                
                // Update Mode 2
                if (mode === 2) {
                    updateMode2(deltaSeconds);
                }
            }
            
            drawGrid();
            updateUI();
            
            requestAnimationFrame(animate);
        }
        
        // Set grid size
        function setGridSize(newSize) {
            newSize = Math.max(1, Math.min(1000, newSize));
            if (newSize === totalCells) return;
            
            totalCells = newSize;
            
            if (mode === 1) {
                const currentImage = imageGrid[0] || images[0];
                imageGrid = [];
                for (let i = 0; i < totalCells; i++) {
                    imageGrid.push(currentImage);
                }
            } else if (mode === 2) {
                initializeMode2();
            }
            
            updateLayout();
        }
        
        // Toggle mode
        function toggleMode() {
            if (mode === 1) {
                mode = 2;
                initializeMode2();
            } else {
                mode = 1;
                const newImage = images[Math.floor(Math.random() * images.length)];
                imageGrid = [];
                for (let i = 0; i < totalCells; i++) {
                    imageGrid.push(newImage);
                }
                mode1BeatCounter = 0;
            }
        }
        
        // Keyboard controls
        // Keyboard controls
        let arrowHeldInterval = null;
        
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'm':
                    toggleMode();
                    break;
                case 'd':
                    canvasColor = canvasColor === '#FFFFFF' ? '#000000' : '#FFFFFF';
                    break;
                case 'p':
                    paused = !paused;
                    break;
                case 'i':
                    showInfo = !showInfo;
                    break;
                case 'arrowleft':
                    e.preventDefault();
                    if (!arrowHeldInterval) {
                        const step = e.shiftKey ? 5 : 1;
                        setGridSize(totalCells - step);
                        // Long-press: rapid removal after 300ms
                        arrowHeldInterval = setTimeout(() => {
                            arrowHeldInterval = setInterval(() => {
                                const rapidStep = e.shiftKey ? 5 : 1;
                                setGridSize(totalCells - rapidStep);
                            }, 100);
                        }, 300);
                    }
                    break;
                case 'arrowright':
                    e.preventDefault();
                    if (!arrowHeldInterval) {
                        const step = e.shiftKey ? 5 : 1;
                        setGridSize(totalCells + step);
                        // Long-press: rapid addition after 300ms
                        arrowHeldInterval = setTimeout(() => {
                            arrowHeldInterval = setInterval(() => {
                                const rapidStep = e.shiftKey ? 5 : 1;
                                setGridSize(totalCells + rapidStep);
                            }, 100);
                        }, 300);
                    }
                    break;
                case '1':
                    currentRandomMode = 0;
                    if (mode === 2) initializeMode2();
                    break;
                case '2':
                    currentRandomMode = 1;
                    if (mode === 2) initializeMode2();
                    break;
                case '3':
                    currentRandomMode = 2;
                    if (mode === 2) initializeMode2();
                    break;
                case '4':
                    currentRandomMode = 3;
                    if (mode === 2) initializeMode2();
                    break;
                case '5':
                    currentRandomMode = 4;
                    if (mode === 2) initializeMode2();
                    break;
                case '6':
                    currentRandomMode = 5;
                    if (mode === 2) initializeMode2();
                    break;
                case '7':
                    currentRandomMode = 6;
                    if (mode === 2) initializeMode2();
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                if (arrowHeldInterval) {
                    clearTimeout(arrowHeldInterval);
                    clearInterval(arrowHeldInterval);
                    arrowHeldInterval = null;
                }
            }
        });
        
        // Mouse wheel control - Adjust grid size on canvas
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomDelta = e.deltaY > 0 ? -0.05 : 0.05;
            zoomLevel = Math.max(0.1, Math.min(1.0, zoomLevel + zoomDelta));
            updateLayout();
        });
        
        // Start button
        document.getElementById('startButton').addEventListener('click', async () => {
            const button = document.getElementById('startButton');
            button.textContent = 'Loading Images...';
            
            await loadImages();
            
            button.classList.add('hidden');
            initializeGrid();
            animate();
        });
    </script>
</body>
</html>

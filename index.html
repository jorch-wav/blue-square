<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blue Square</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; background: #000; overflow: hidden; }
        #canvas { display: block; }
        #info {
            position: absolute; top: 20px; left: 20px; color: white;
            font-size: 14px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            user-select: none; z-index: 10; line-height: 1.6;
        }
        #controls {
            position: absolute; bottom: 20px; left: 20px; color: white;
            font-size: 12px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            user-select: none; z-index: 10; line-height: 1.8;
        }
        .key {
            display: inline-block; padding: 2px 6px;
            background: rgba(255,255,255,0.2); border-radius: 3px; margin-right: 4px;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="loading">
        <div>Loading Blue Square...</div>
        <div id="loadProgress">0%</div>
    </div>
    <div id="info" style="display: none;">
        <div><strong>BLUE SQUARE</strong></div>
        <div>Mode: <span id="mode">Uniform</span></div>
        <div>Preset: <span id="preset">-</span></div>
        <div>Grid: <span id="cells">64</span> cells</div>
        <div>Beat: <span id="beat">1/8</span></div>
    </div>
    <div id="controls" style="display: none;">
        <div><span class="key">M</span> Mode | <span class="key">P</span> Pause | <span class="key">←→</span> Presets</div>
        <div><span class="key">↑↓</span> Speed | <span class="key">+</span> Zoom In | <span class="key">-</span> Zoom Out</div>
        <div><span class="key">1-7</span> Jump Preset | <span class="key">Wheel</span> Grid Size</div>
    </div>

    <script>
        const TOTAL_IMAGES = 230;
        const BATCH_SIZE = 30; // Load 30 at a time
        const DEFAULT_CELLS = 64;
        const FPS = 60;
        const FRAMES_PER_BEAT = 30; // 30 frames = 0.5 sec at 60fps = 120 BPM
        
        let mode = 1;
        let currentPreset = 0;
        let cellCount = DEFAULT_CELLS;
        let paused = false;
        let animationSpeed = 1.0;
        let scale = 1.0;
        
        let images = [];
        let loadedImages = new Set();
        let grid = [];
        let cols = 0, rows = 0, cellSize = 0;
        
        let frameCount = 0;
        let beatCount = 0;
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const presets = [
            { name: 'Calm', speed: 0.3, changeRate: 0.1 },
            { name: 'Breathing', speed: 0.6, changeRate: 0.2 },
            { name: 'Waves', speed: 0.8, changeRate: 0.3 },
            { name: 'Sparse', speed: 0.5, changeRate: 0.15 },
            { name: 'Dense', speed: 1.0, changeRate: 0.4 },
            { name: 'Energetic', speed: 1.5, changeRate: 0.5 },
            { name: 'Glitch', speed: 2.0, changeRate: 0.7 }
        ];
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            calculateLayout();
        }
        
        function calculateLayout() {
            cols = Math.max(1, Math.ceil(Math.sqrt(cellCount)));
            rows = Math.ceil(cellCount / cols);
            const cellWidth = Math.floor(canvas.width / cols);
            const cellHeight = Math.floor(canvas.height / rows);
            cellSize = Math.min(cellWidth, cellHeight) * scale;
            updateInfo();
        }
        
        // Load images progressively in batches
        async function loadImages() {
            let loaded = 0;
            
            // Pre-create image objects
            for (let i = 1; i <= TOTAL_IMAGES; i++) {
                images[i - 1] = null;
            }
            
            // Load in batches
            for (let batch = 0; batch < Math.ceil(TOTAL_IMAGES / BATCH_SIZE); batch++) {
                const start = batch * BATCH_SIZE + 1;
                const end = Math.min((batch + 1) * BATCH_SIZE, TOTAL_IMAGES);
                
                const promises = [];
                for (let i = start; i <= end; i++) {
                    const idx = i - 1;
                    promises.push(new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            images[idx] = img;
                            loadedImages.add(idx);
                            loaded++;
                            const percent = Math.floor((loaded / TOTAL_IMAGES) * 100);
                            document.getElementById('loadProgress').textContent = percent + '%';
                            resolve();
                        };
                        img.onerror = () => {
                            loaded++;
                            resolve();
                        };
                        img.src = `images/blue-${i}.jpg`;
                    }));
                }
                
                await Promise.all(promises);
                
                // Start animation after first batch
                if (batch === 0 && !grid.length) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('info').style.display = 'block';
                    document.getElementById('controls').style.display = 'block';
                    initializeGrid();
                    animate();
                }
            }
            
            console.log(`Loaded ${loadedImages.size} images`);
        }
        
        function initializeGrid() {
            grid = [];
            for (let i = 0; i < cellCount; i++) {
                grid.push({
                    imageIndex: Math.floor(Math.random() * TOTAL_IMAGES),
                    nextImageIndex: Math.floor(Math.random() * TOTAL_IMAGES),
                    visible: true,
                    alpha: 1.0,
                    transitioning: false,
                    transitionProgress: 0,
                    updateOffset: Math.random() * 0.3 // 0-30% offset for organic feel
                });
            }
        }
        
        function updateUniform() {
            frameCount++;
            
            const framesPerBeat = FRAMES_PER_BEAT / animationSpeed;
            
            if (frameCount >= framesPerBeat) {
                frameCount = 0;
                beatCount++;
                
                if (beatCount % 8 === 0) {
                    // Start transition for all cells with slight offset
                    for (let cell of grid) {
                        cell.nextImageIndex = Math.floor(Math.random() * TOTAL_IMAGES);
                        cell.transitioning = true;
                        cell.transitionProgress = 0;
                    }
                }
                updateInfo();
            }
            
            // Update transitions smoothly
            for (let cell of grid) {
                if (cell.transitioning) {
                    cell.transitionProgress += 0.15; // Smooth fade speed
                    
                    if (cell.transitionProgress >= 1.0) {
                        cell.imageIndex = cell.nextImageIndex;
                        cell.transitioning = false;
                        cell.transitionProgress = 0;
                        cell.alpha = 1.0;
                    }
                }
            }
        }
        
        function updateRandom() {
            frameCount++;
            
            const preset = presets[currentPreset];
            const framesPerBeat = FRAMES_PER_BEAT / (animationSpeed * preset.speed);
            
            if (frameCount >= framesPerBeat) {
                frameCount = 0;
                beatCount++;
                
                for (let i = 0; i < grid.length; i++) {
                    const cell = grid[i];
                    // Use cell's offset for organic timing
                    const shouldUpdate = Math.random() < (preset.changeRate + cell.updateOffset * 0.1);
                    
                    if (shouldUpdate) {
                        cell.nextImageIndex = Math.floor(Math.random() * TOTAL_IMAGES);
                        cell.transitioning = true;
                        cell.transitionProgress = 0;
                        cell.visible = Math.random() > 0.1;
                    }
                }
                updateInfo();
            }
            
            // Update transitions
            for (let cell of grid) {
                if (cell.transitioning) {
                    cell.transitionProgress += 0.12;
                    
                    if (cell.transitionProgress >= 1.0) {
                        cell.imageIndex = cell.nextImageIndex;
                        cell.transitioning = false;
                if (cell.transitioning) {
                    // Cross-fade between old and new image
                    const oldImg = images[cell.imageIndex];
                    const newImg = images[cell.nextImageIndex];
                    
                    // Draw old image fading out
                    if (oldImg) {
                        ctx.globalAlpha = 1.0 - cell.transitionProgress;
                        ctx.drawImage(oldImg, x, y, cellSize, cellSize);
                    }
                    
                    // Draw new image fading in
                    if (newImg) {
                        ctx.globalAlpha = cell.transitionProgress;
                        ctx.drawImage(newImg, x, y, cellSize, cellSize);
                    }
                    
                    ctx.globalAlpha = 1.0;
                } else {
                    // Draw current image normally
                    const img = images[cell.imageIndex];
                    if (img) {
                        ctx.drawImage(img, x, y, cellSize, cellSize);
                    }
                }
            }
        }
        
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const offsetX = (canvas.width - (cellSize * cols)) / 2;
            const offsetY = (canvas.height - (cellSize * rows)) / 2;
            
            for (let i = 0; i < grid.length && i < cellCount; i++) {
                const cell = grid[i];
                if (!cell.visible) continue;
                
                const col = i % cols;
                const row = Math.floor(i / cols);
                const x = offsetX + (col * cellSize);
                const y = offsetY + (row * cellSize);
                
                const img = images[cell.imageIndex];
                if (img) {
                    ctx.drawImage(img, x, y, cellSize, cellSize);
                }
            }
        }
        
        function animate() {
            if (!paused) {
                if (mode === 1) updateUniform();
                else updateRandom();
            }
            draw();
            requestAnimationFrame(animate);
        }
        
        function updateInfo() {
            document.getElementById('mode').textContent = mode === 1 ? 'Uniform' : 'Random';
            document.getElementById('preset').textContent = mode === 2 ? presets[currentPreset].name : '-';
            document.getElementById('cells').textContent = cellCount;
            document.getElementById('beat').textContent = `${(beatCount % 8) + 1}/8`;
        }
        
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'm':
                    mode = mode === 1 ? 2 : 1;
                    beatCount = 0;
                    updateInfo();
                    break;
                case 'p':
                    paused = !paused;
                    break;
                case 'arrowleft':
                    if (mode === 2) {
                        currentPreset = (currentPreset - 1 + presets.length) % presets.length;
                        updateInfo();
                    }
                    break;
                case 'arrowright':
                    if (mode === 2) {
                        currentPreset = (currentPreset + 1) % presets.length;
                        updateInfo();
                    }
                    break;
                case 'arrowup':
                    animationSpeed = Math.min(5.0, animationSpeed + 0.2);
                    break;
                case 'arrowdown':
                    animationSpeed = Math.max(0.1, animationSpeed - 0.2);
                    break;
                case '+':
                case '=':
                    scale = Math.min(2.0, scale + 0.1);
                    calculateLayout();
                    break;
                case '-':
                case '_':
                    scale = Math.max(0.3, scale - 0.1);
                    nextImageIndex: Math.floor(Math.random() * TOTAL_IMAGES),
                    visible: true,
                    alpha: 1.0,
                    transitioning: false,
                    transitionProgress: 0,
                    updateOffset: Math.random() * 0.3ut();
                    break;
                case '1': case '2': case '3': case '4': case '5': case '6': case '7':
                    if (mode === 2) {
                        currentPreset = parseInt(e.key) - 1;
                        updateInfo();
                    }
                    break;
            }
        });
        
        document.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY < 0) {
                cellCount = Math.min(400, cellCount + 4);
            } else {
                cellCount = Math.max(4, cellCount - 4);
            }
            while (grid.length < cellCount) {
                grid.push({
                    imageIndex: Math.floor(Math.random() * TOTAL_IMAGES),
                    visible: true
                });
            }
            grid.length = cellCount;
            calculateLayout();
        });
        
        window.addEventListener('resize', resizeCanvas);
        
        resizeCanvas();
        loadImages();
    </script>
</body>
</html>
